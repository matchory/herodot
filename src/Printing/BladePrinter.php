<?php

declare(strict_types=1);

namespace Matchory\Herodot\Printing;

use Illuminate\Config\Repository;
use Illuminate\Contracts\Filesystem\Filesystem;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\App;
use Illuminate\Support\Facades\File;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\View;
use Illuminate\Support\Str;
use League\CommonMark\MarkdownConverterInterface;
use Matchory\Herodot\Contracts\Printer;
use Matchory\Herodot\Entities\Endpoint;
use SplFileInfo;

use function file_get_contents;
use function in_array;
use function is_dir;
use function is_readable;
use function rtrim;

use const DIRECTORY_SEPARATOR;

/**
 * Blade Printer
 * =============
 * Prints the documentation using a Blade template.
 *
 * @package Matchory\Herodot\Printing
 */
class BladePrinter implements Printer
{
    protected array $config;

    protected MarkdownConverterInterface $markdownConverter;

    public function __construct(
        Repository $config,
        MarkdownConverterInterface $markdownConverter
    ) {
        $this->config = $config->get('herodot.blade', []);
        $this->markdownConverter = $markdownConverter;
    }

    /**
     * @inheritDoc
     */
    public function print(Collection $endpoints): void
    {
        $groups = $this->group($endpoints);
        $pages = $this->pages();
        $output = $this->render($groups, $pages);

        $this->save($output);
    }

    /**
     * Renders the documentation to a string. By default, this will invoke the
     * main view and render it with the endpoint groups and documentation pages
     * as loaded by the printer.
     *
     * @param Collection $groups Map of endpoints to their group name.
     * @param Collection $pages  Map of pages to their title.
     *
     * @return string Rendered documentation.
     */
    protected function render(Collection $groups, Collection $pages): string
    {
        $viewName = $this->mainView();
        $view = View::make($viewName, [
            'groups' => $groups,
            'pages' => $pages,
        ]);

        return $view->render();
    }

    /**
     * Groups the endpoints by mapping them to their group name. By default,
     * this will group the endpoints and sort them alphabetically by group name.
     *
     * @param Collection $endpoints List of endpoints.
     *
     * @return Collection Map of endpoints to their group.
     */
    protected function group(Collection $endpoints): Collection
    {
        return $endpoints
            ->groupBy(fn(Endpoint $endpoint) => $endpoint->getGroup())
            ->sort();
    }

    /**
     * Retrieves the absolute path to the pages directory.
     *
     * @return string|null Path to the directory or null if not configured.
     */
    protected function pagesPath(): ?string
    {
        $pagesDirectory = $this->config['pages_directory'] ?? null;

        if ( ! $pagesDirectory) {
            return null;
        }

        $basePath = rtrim(App::basePath(), DIRECTORY_SEPARATOR);

        return $basePath . '/' . $pagesDirectory;
    }

    /**
     * Retrieves all additional documentation pages to be included in the final
     * documentation as generated by the Blade printer. Pages will be added as
     * top-level navigation items and allow providing non-code bound content.
     *
     * @return Collection Collection of page content mapped to their title.
     */
    protected function pages(): Collection
    {
        $path = $this->pagesPath();

        if ( ! $path) {
            return Collection::empty();
        }

        if ( ! is_dir($path)) {
            Log::warning(
                "Expected additional documentation at '{$path}', but " .
                'found a file instead of a directory. It will be ignored.'
            );

            return Collection::empty();
        }

        if ( ! is_readable($path)) {
            Log::warning(
                "Expected additional documentation at '{$path}', but " .
                'the directory was not readable. It will be ignored.'
            );

            return Collection::empty();
        }

        return $this

            // Load all files as SPLFileInfo instances
            ->pageFiles($path)

            // Make sure we only load supported files
            ->filter(fn(SplFileInfo $file) => $this->isPage($file))

            // Map pages to their title
            ->mapWithKeys(fn(SplFileInfo $file): array => [
                $this->pageTitle($file) => $this->pageContent($file),
            ]);
    }

    /**
     * Loads all page files from the file system. This method MUST retrieve a
     * collection of SPLFileInfo objects.
     *
     * @param string $path Path to the pages directory.
     *
     * @return Collection Collection of SPLFileInfo objects.
     */
    protected function pageFiles(string $path): Collection
    {
        return Collection::make(File::allFiles(
            $path,
            false
        ));
    }

    /**
     * Checks whether a file is actually a page. By default, this method simply
     * validates the file extension is on the allow list.
     *
     * @param SplFileInfo $file File to check.
     *
     * @return bool Whether the file is a page.
     */
    protected function isPage(SplFileInfo $file): bool
    {
        return in_array(
            $file->getExtension(),
            $this->config['pages_extensions'],
            true
        );
    }

    /**
     * Retrieves the title of a page given the file instance. By default, this
     * method converts the basename of the file (filename without extension) to
     * a title cased string.
     *
     * @param SplFileInfo $file File to retrieve the title for.
     *
     * @return string Title of the documentation page.
     */
    protected function pageTitle(SplFileInfo $file): string
    {
        $basename = $file->getBasename('.' . $file->getExtension());

        return (string)Str
            ::of($basename)
            ->kebab()
            ->replace(['-', '_'], ' ')
            ->title()
            ->words();
    }

    /**
     * Retrieves the page content for a page file. By default, this method
     * simply reads the file and interprets it as plain text.
     *
     * @param SplFileInfo $file File to retrieve the content for.
     *
     * @return string Content as it should be included in the output docs.
     */
    protected function pageContent(SplFileInfo $file): string
    {
        return file_get_contents($file->getPathname());
    }

    /**
     * Retrieves the desired path to the output file relative to the storage
     * directory of the project.
     *
     * @return string Relative output path.
     */
    protected function outputPath(): string
    {
        return $this->config['output_file'] ?? 'herodot/index.html';
    }

    /**
     * Retrieves the name of the main view used to render the output with. This
     * defaults to Herodot's index template.
     *
     * @return string Name of the view.
     */
    protected function mainView(): string
    {
        return 'herodot::index';
    }

    /**
     * Saves the output to the output disk. By default, this simply saves the
     * output string into the path.
     *
     * @param string $output String output to write to the disk.
     *
     * @return bool Whether the write was successful.
     */
    protected function save(string $output): bool
    {
        $disk = $this->outputDisk();
        $path = $this->outputPath();

        return $disk->put($path, $output);
    }

    /**
     * Retrieves the disk to write the output on. The output path will be scoped
     * to this filesystem. This defaults to the local disk, which should be
     * configured to write the documentation into the application files.
     *
     * @return Filesystem Filesystem to write the output on.
     */
    protected function outputDisk(): Filesystem
    {
        return Storage::disk('local');
    }
}
